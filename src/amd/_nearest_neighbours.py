"""Implements core function nearest_neighbours used for AMD and PDD
calculations.
"""

from typing import Tuple, Iterable
from itertools import product

import numba
import numpy as np
import numpy.typing as npt
from scipy.spatial import KDTree


def nearest_neighbours(
        motif: npt.NDArray,
        cell: npt.NDArray,
        x: npt.NDArray,
        k: int
) -> Tuple[npt.NDArray[np.float64], ...]:
    """
    Given a periodic set represented by (motif, cell) and an integer k,
    find the k nearest neighbours in the periodic set to points in x.

    Parameters
    ----------
    motif : :class:`numpy.ndarray`
        Orthogonal (Cartesian) coords of the motif, shape (no points,
        dims).
    cell : :class:`numpy.ndarray`
        Orthogonal (Cartesian) coords of the unit cell, shape (dims,
        dims).
    x : :class:`numpy.ndarray`
        Array of points to query for neighbours. For invariants of
        crystals this is the asymmetric unit.
    k : int
        Number of nearest neighbours to find for each point in x.

    Returns
    -------
    dists : numpy.ndarray
        Array shape (motif.shape[0], k) of distances from points in x
        to their k nearest neighbours in the periodic set, in order.
        E.g. dists[m][n] is the distance from x[m] to its n-th nearest
        neighbour in the periodic set.
    cloud : numpy.ndarray
        Collection of points in the periodic set that was generated
        during the nearest neighbour search.
    inds : numpy.ndarray
        Array shape (motif.shape[0], k) containing the indices of
        nearest neighbours in cloud. E.g. the n-th nearest neighbour to
        the m-th motif point is cloud[inds[m][n]].
    """

    # generate initial cloud of points, at least k + one more layer
    cloud_generator = generate_concentric_cloud(motif, cell)
    n_points = 0
    cloud = []
    while n_points <= k:
        layer = next(cloud_generator)
        n_points += layer.shape[0]
        cloud.append(layer)
    cloud.append(next(cloud_generator))
    cloud = np.concatenate(cloud)

    # find k nearest neighbours in cloud of points in x
    dists_, inds = KDTree(
        cloud, leafsize=30, compact_nodes=False, balanced_tree=False
    ).query(x, k=k)
    dists = np.zeros_like(dists_, dtype=np.float64)

    # add layers & find k nearest neighbours until they don't change
    while not np.allclose(dists, dists_, atol=1e-10, rtol=0):
        dists = dists_
        cloud = np.vstack((cloud, next(cloud_generator)))
        dists_, inds = KDTree(
            cloud, leafsize=30, compact_nodes=False, balanced_tree=False
        ).query(x, k=k)

    return dists_, cloud, inds


def nearest_neighbours_minval(
        motif: npt.NDArray,
        cell: npt.NDArray,
        min_val: float
) -> npt.NDArray[np.float64]:
    """Used in ``PDD_reconstructable``. Returns the same `dists`/PDD
    matrix as ``nearest_neighbours``, but with enough columns such that
    all values in the last column are at least ``min_val``. Unlike
    ``nearest_neighbours``, it does not take an array ``x`` but finds
    neighbours to motif points only, and does not return the cloud or
    indices of the nearest neighbours.
    """

    cloud_generator = generate_concentric_cloud(motif, cell)

    cloud = []
    for _ in range(3):
        cloud.append(next(cloud_generator))
    cloud = np.concatenate(cloud)

    dists_, inds = KDTree(
        cloud, leafsize=30, compact_nodes=False, balanced_tree=False
    ).query(motif, k=cloud.shape[0])
    dists = np.zeros_like(dists_)

    while True:
        if np.all(dists[:, -1] >= min_val):
            col_where = np.argwhere(np.all(dists >= min_val, axis=0))[0][0] + 1
            if np.array_equal(dists[:, :col_where], dists_[:, :col_where]):
                break
        dists = dists_
        cloud = np.vstack((cloud, next(cloud_generator)))
        dists_, inds = KDTree(
            cloud, leafsize=30, compact_nodes=False, balanced_tree=False
        ).query(motif, k=cloud.shape[0])

    k = np.argwhere(np.all(dists >= min_val, axis=0))[0][0]
    return dists_[:, 1:k+1], cloud, inds


def generate_concentric_cloud(
        motif: npt.NDArray,
        cell: npt.NDArray
) -> Iterable[npt.NDArray[np.float64]]:
    """
    Generates batches of points from a periodic set given by (motif,
    cell) which get successively further away from the origin.

    Each yield gives all points (that have not already been yielded)
    which lie in a unit cell whose corner lattice point was generated by
    ``generate_integer_lattice(motif.shape[1])``.

    Parameters
    ----------
    motif : :class:`numpy.ndarray`
        Cartesian representation of the motif, shape (no points, dims).
    cell : :class:`numpy.ndarray`
        Cartesian representation of the unit cell, shape (dims, dims).

    Yields
    -------
    :class:`numpy.ndarray`
        Yields arrays of points from the periodic set.
    """

    for int_lattice in generate_integer_lattice(cell.shape[0]):
        yield _int_lattice_to_cloud(motif, cell, int_lattice)


def generate_integer_lattice(dims: int) -> Iterable[npt.NDArray[np.float64]]:
    """Generates batches of integer lattice points. Each yield gives all
    points (that have not already been yielded) inside a sphere centered
    at the origin with radius d. d starts at 0 and increments by 1 on
    each loop.

    Parameters
    ----------
    dims : int
        The dimension of Euclidean space the lattice is in.

    Yields
    -------
    :class:`numpy.ndarray`
        Yields arrays of integer points in dims dimensional Euclidean
        space.
    """

    d = 0

    if dims == 1:
        yield np.array([[0]], dtype=np.float64)
        while True:
            d += 1
            yield np.array([[-d], [d]], dtype=np.float64)

    ymax = {}
    while True:
        positive_int_lattice = []
        while True:
            batch = []
            for xy in product(range(d + 1), repeat=dims-1):
                if xy not in ymax:
                    ymax[xy] = 0
                if _in_sphere(xy, ymax[xy], d):
                    batch.append((*xy, ymax[xy]))
                    ymax[xy] += 1
            if not batch:
                break
            positive_int_lattice.extend(batch)

        yield _reflect_positive_lattice(np.array(positive_int_lattice))
        d += 1


@numba.njit(cache=True)
def _reflect_positive_lattice(
        positive_int_lattice: npt.NDArray
) -> npt.NDArray[np.float64]:
    """Reflect points in the positive quadrant across all combinations
    of axes, without duplicating points that are invariant under
    reflections.
    """

    dims = positive_int_lattice.shape[-1]
    batches = []
    batches.extend(positive_int_lattice)

    for n_reflections in range(1, dims + 1):

        indices = np.arange(n_reflections)
        batches.extend(_reflect_points(positive_int_lattice, indices))

        while True:
            i = n_reflections - 1
            for _ in range(n_reflections):
                if indices[i] != i + dims - n_reflections:
                    break
                i -= 1
            else:
                break
            indices[i] += 1
            for j in range(i + 1, n_reflections):
                indices[j] = indices[j-1] + 1

            batches.extend(_reflect_points(positive_int_lattice, indices))

    int_lattice = np.empty(shape=(len(batches), dims), dtype=np.float64)
    for i in range(len(batches)):
        int_lattice[i] = batches[i]

    return int_lattice


@numba.njit(cache=True)
def _reflect_points(
        positive_int_lattice: npt.NDArray,
        indices: npt.NDArray
) -> npt.NDArray:
    """Reflect points in `positive_int_lattice` in the axes described by
    `indices`. Does not duplicate invariant points.
    """
    not_on_axes = (positive_int_lattice[:, indices] == 0).sum(axis=-1) == 0
    int_lattice = positive_int_lattice[not_on_axes]
    int_lattice[:, indices] *= -1
    return int_lattice


@numba.njit(cache=True)
def _int_lattice_to_cloud(
        motif: npt.NDArray,
        cell: npt.NDArray,
        int_lattice: npt.NDArray
) -> npt.NDArray[np.float64]:
    """Transform a batch of integer lattice points (given by
    generate_integer_lattice) into a cloud of points from a periodic set
    described by motif and cell.
    """

    m = len(motif)
    lattice = int_lattice @ cell
    layer = np.empty((m * len(lattice), cell.shape[0]), dtype=np.float64)
    i1 = 0
    for translation in lattice:
        i2 = i1 + m
        layer[i1:i2] = motif + translation
        i1 = i2
    return layer


@numba.njit(cache=True)
def _in_sphere(xy: Tuple[float, float], z: float, d: float) -> bool:
    s = z ** 2
    for val in xy:
        s += val ** 2
    return s <= d ** 2
